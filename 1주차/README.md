

# 📅 1주차

## 🟢 1일차

### 🐍 파이썬(Python)

#### ✅ 장점

- **문법이 간단**하여 초보자 및 교육용으로 적합
- **방대한 패키지**와 생태계 보유
- **R 언어**에서 파이썬으로 많이 넘어감 (실제 서비스에 활용하기 유리)
- **머신러닝/딥러닝 연구 결과**가 파이썬으로 많이 배포됨
- **데이터 분석/AI 프레임워크**(TensorFlow, PyTorch, Chainer, MXNet, Theano 등) 대부분이 파이썬 우선 지원
- **최신 알고리즘 연구**가 파이썬으로 활발히 이루어짐


#### ⚡️ 특징

- **인터프리터 언어** (코드를 한 줄씩 실행)
- **엄격한 문법** (예: 4칸 들여쓰기 필수)


### 💻 Google Colab

> 구글이 제공하는 오픈 클라우드 기반 Jupyter Notebook 환경

#### ⭐️ 특징

- **어디서나 동일한 개발환경** 제공
- **ML/DL 필수 라이브러리**(Pandas, TensorFlow, Keras 등) 기본 제공
- **Google의 GPU/TPU** 무료 사용 가능


#### 🛠️ 사용법

- **코드 셀**
    - `Ctrl + Enter` : 셀 실행
    - `Shift + Enter` : 실행 후 다음 셀로 이동
    - `Alt + Enter` : 실행 후 아래에 새 셀 생성
- **텍스트 셀**
    - 일반 텍스트 및 **Markdown** 문법 지원


###  AI 엔지니어링

#### 💡 컴퓨터 언어학

- **자연어 처리** + 컴퓨터 언어학 알고리즘으로 데이터 이해 및 추론
- 통계적 머신러닝과 최신 딥러닝 기술 활용


#### 🔄 머신러닝: 새로운 프로그래밍 패러다임

- **기존:** 규칙 + 데이터 → 해답
- **ML:** 데이터 + 해답 → 규칙(모델)


#### 👨‍💻 AI 관련 직군

| 직군 | 주요 역할 |
| :-- | :-- |
| 데이터 사이언티스트 | 현장 문제를 데이터 문제로 전환, 수학/통계 기반 검증 |
| 데이터 엔지니어 | 데이터 인프라 구축 및 관리, 데이터 흐름 설계 |
| ML 엔지니어 | 데이터 기반 모델 설계 및 서비스 적용 |
| 데이터 애널리스트 | 데이터 분석 결과 도출 및 프레젠테이션 |

## 🟢 2일차

### 🐍 파이썬 문법

#### 함수 시그니처(Signature)

- `/` 왼쪽: 파라미터=아규먼트 형식 사용 불가
- `*` 오른쪽: 파라미터=아규먼트 형식만 사용 가능

```python
sort(self, /, *, key=None, reverse=False)
# self는 list 본인, key와 reverse는 반드시 key=value로 지정
```


#### range()와 지연평가(Lazy Evaluation)

- **지연평가:** 조건만 메모리에 저장, 실제 사용 시 평가
- **장점:** 메모리 효율적


###  단락 평가(Short-circuit Evaluation)

> 논리 연산자(AND, OR 등)에서 첫 번째 피연산자의 값만으로 결과가 정해지면 두 번째 피연산자는 평가하지 않는 방식

#### ✔️ 장점 및 활용

- **에러 방지:**

```c
if (ptr != NULL && ptr->method()) { ... }
```

- **성능 최적화:** 불필요한 연산/함수 호출 방지
- **제어 구조 역할:** 조건문처럼 활용 가능


#### ⚠️ 주의사항

- **모든 언어에서 지원하지 않음** (예: Fortran)
- **XOR 등은 단락 평가 불가**
- **부작용(side effect) 함수와 함께 사용 시 주의**

> **단락 평가는 안전성과 효율성을 높여주는 중요한 프로그래밍 기법이지만, 언어별 지원 여부와 복잡한 논리식에서의 사용에 주의가 필요합니다.**

## 📚 용어정리

| 용어 | 요약 |
| :-- | :-- |
| **머신러닝(ML)** | 데이터를 통해 스스로 학습하고 성능을 개선하는 인공지능의 한 분야 |
| **딥러닝(DL)** | 인공신경망 기반, 다층 구조로 복잡한 패턴을 학습하는 머신러닝의 하위 분야 |
| **텐서플로우(TensorFlow)** | 구글 개발, 대규모 데이터 처리와 AI 작업에 적합한 오픈소스 딥러닝 프레임워크 |
| **파이토치(PyTorch)** | 페이스북 개발, 동적 계산 그래프와 직관적 파이썬 문법으로 연구에 널리 사용 |
| **체이너(Chainer)** | 파이썬 기반, 동적 계산 그래프 지원, 유연한 딥러닝 모델 개발 가능 |
| **아파치 MXNet** | 다양한 언어 지원, 멀티 GPU 환경에서 뛰어난 성능의 딥러닝 프레임워크 |
| **테아노(Theano)** | 파이썬용 수치 계산 라이브러리, 심볼릭 계산과 자동 미분 지원 (2017년 개발 중단) |
| **주피터 노트북** | 웹 기반 인터랙티브 환경, 코드/수식/시각화/설명을 한 문서에서 작성·실행 |
| **Pandas** | 파이썬 데이터 분석 라이브러리, 데이터프레임 구조로 조작·분석에 최적화 |
| **Keras** | 딥러닝 모델을 쉽고 빠르게 구축하는 고수준 API, 주로 TensorFlow 백엔드 사용 |



# 3일차 파이썬 정리
---

## ✅ Flag 변수의 활용

**Flag 변수**란 프로그램의 흐름을 제어하거나 상태를 나타내기 위해 사용하는 boolean 변수입니다.  
주로 특정 조건이 충족되었는지, 특정 이벤트가 발생했는지 등을 나타내는 데 쓰입니다.

### 주요 활용 예시

- **상태 표시**  
  예: `isLoggedIn`, `isLoading`, `isError`, `isComplete` 등으로 현재 상태를 명확히 표현

- **조건 제어**  
  반복문이나 조건문에서 특정 조건이 충족될 때까지 반복하거나, 조건에 따라 로직 분기

- **오류 처리**  
  오류 발생 여부를 플래그로 표시하여, 오류 발생 시 추가적인 처리 가능

- **상태 변경**  
  예: `isFirstRun` 등 특정 동작의 완료 여부를 나타내어, 이후 동작에 영향

### 사용 시 주의사항

- **명확한 이름 부여**  
  플래그가 어떤 상태를 나타내는지 알 수 있도록 직관적으로 이름 지정

- **남용 방지**  
  플래그 변수를 과도하게 사용하면 코드가 복잡해질 수 있으니, 꼭 필요한 경우에만 사용

- **유효성 관리**  
  플래그의 초기값과 사용 범위를 명확히 정의해 예기치 않은 오류 방지

---

## 🧩 파이썬의 Case 문 (match-case)

파이썬은 오랫동안 전통적인 switch-case 문법을 지원하지 않았지만,  
**파이썬 3.10부터 match-case 문법**이 도입되어 switch-case와 유사한 기능을 사용할 수 있습니다.

### 기본 구조

```python
match 변수:
    case 값1:
        # 값1에 해당하는 실행문
    case 값2:
        # 값2에 해당하는 실행문
    case _:
        # 그 외의 경우 (와일드카드, default 역할)
```


### 특징

- 여러 값을 한 번에 매칭할 때 `|` 연산자 사용 가능
- 리스트, 튜플 등 다양한 패턴 매칭 지원
- 조건부(case ... if ...) 매칭 가능

---

## 🏗️ 구조적 패턴 매칭 (Structural Pattern Matching)

**구조적 패턴 매칭**은 단순 값 비교를 넘어서  
데이터의 구조(예: 튜플, 리스트, 객체 등)를 기반으로 다양한 패턴을 정의하고 분기 처리할 수 있는 문법입니다.

- case 문에서 언패킹과 변수 바인딩이 직접 가능
- 복잡한 if-elif-else 대신 사용하여 가독성 향상

### 예시



```python
shape = ("rectangle", 10, 20)

match shape:
    case ("rectangle", width, height):
        area = width * height
    case ("circle", radius):
        area = 3.14 * radius * radius
    case _:
        area = None
```


---

## ⚡️ 다른 언어의 switch-case와의 차이

| 구분 | 전통적 switch-case (C, Java 등) | 파이썬 match-case (3.10 이상) |
|---|---|---|
| **매칭 대상** | 정수, 문자, 문자열 등 단순 값 | 값, 리스트, 튜플, 객체 등 복합 자료구조 |
| **패턴 매칭** | 값의 동등성만 비교 | 구조와 값, 타입, 언패킹, 가드(조건) 등 다양한 패턴 지원 |
| **break 필요 여부** | 각 case마다 break 필요 | break 불필요, 첫 번째 일치 case만 실행 |
| **기본 케이스** | default 키워드 | `_`(언더바) 사용 |
| **OR 조건** | 일부 언어만 지원 | `|` 연산자 사용 |
| **복합 자료구조** | 지원 안 함 | 튜플, 리스트, 데이터클래스 등 직접 매칭 |
| **조건부 분기** | case 내부에서 if문 사용 | `case x if ...` 형태로 case 자체에 조건 추가 가능 |

---

## 🦭 Walrus Operator (`:=`)

**바다코끼리 연산자(Walrus operator)는** `:=` 기호로,  
**변수에 값을 할당하면서 동시에 그 값을 표현식 내에서 사용할 수 있게 해주는 대입 표현식**입니다.  
파이썬 3.8부터 도입되었습니다.

### 특징

- **할당과 반환을 동시에 수행**  
  예: `if (n := len(a)) > 10:`

- **코드를 더 간결하고 직관적으로 작성**  
  (기존에는 값을 변수에 할당하고, 따로 조건문 등에서 다시 그 변수를 사용해야 했던 부분을 한 줄로 줄임)

- **반복문, 조건문, 리스트 컴프리헨션 등 다양한 곳에서 활용 가능**

- **괄호를 사용해 명확하게 구분**  
  괄호 없이 사용하면 문법이 모호해질 수 있음

### 예시


```python
# 할당과 동시에 조건 검사
if (n := len(a)) > 5:
    print(f"List is too long ({n} elements)")

# while 루프에서 읽기와 처리 동시 수행
while (chunk := file.read(256)) != '':
    process(chunk)

# 리스트 컴프리헨션 내에서 값 할당 및 필터링
[clean_name.title() for name in names \
if (clean_name := normalize(name)) in allowed_names]

```


### 장점

- 중복 계산을 줄여 성능 최적화
- 코드 가독성 및 간결성 향상
- 변수의 스코프를 좁혀 불필요한 변수 최소화

---

## 🟢 4일차

---

### 🔁 Iterable 객체

- 내부에 여러 요소를 가지고 있으며, *한 번에 하나씩* 꺼낼 수 있는 **반복(iteration) 가능한 객체**
- **리스트, 문자열, 집합(Set), 딕셔너리** 등이 대표적
- 파이썬에서는 `for`문 등 반복문에서 활용 가능

#### ✨ 특징

- **반복 가능:** `for`문 등에서 사용
- **프로토콜 만족:**  
  - `__iter__()` 메서드가 있어야 하며, 이 메서드는 이터레이터(iterator) 객체를 반환
  - 이터레이터는 `__next__()` 메서드로 요소를 하나씩 반환

#### 🔎 iterable vs iterator

| 구분 | iterable(이터러블) | iterator(이터레이터) |
| :-- | :-- | :-- |
| 정의 | 반복 가능한 객체 | 실제로 반복을 수행하는 객체 |
| 예시 | 리스트, 문자열, 집합, 딕셔너리 등 | `iter()` 결과, 리스트의 이터레이터 등 |
| 필수 메서드 | `__iter__()` | `__iter__()`, `__next__()` |
| 사용 목적 | 반복문에 전달해 반복 시작 | 반복문 내부에서 실제 값 반환 |

#### 🛠️ 직접 iterator 만들기

```python
class CountUpTo:
def init(self, max):
self.max = max
self.current = 1

def __iter__(self):
    return self

def __next__(self):
    if self.current > self.max:
        raise StopIteration
    self.current += 1
    return self.current - 1

#사용 예시
counter = CountUpTo(5)
for number in counter:
print(number)
```

---

### 📝 Docstring

- **모듈, 함수, 클래스, 메서드** 정의 바로 아래에 위치하는 문자열
- 코드 블록의 **용도, 사용법, 동작 방식**을 문서화
- `__doc__` 속성 또는 `help()` 함수로 확인 가능

#### ✏️ 작성법

- **모듈:** 파일 맨 위
- **클래스/함수/메서드:** 선언 직후, 첫 줄에 큰따옴표 3개(`"""`)로 작성

```python
def add(a, b):
"""
두 숫자를 더한 값을 반환합니다.
Args:
    a (int): 첫 번째 숫자
    b (int): 두 번째 숫자

Returns:
    int: 두 숫자의 합
"""
return a + b
```

#### 💡 특징 & 활용

- 코드의 사용법, 인자, 반환값, 예외 등 설명 가능
- 자동 문서화 도구(Sphinx 등)에서 활용
- 유지보수, 협업, 재사용성 향상

---

### 🛠️ Destructive & Undestructive Function

#### ⚠️ Destructive function (파괴적 함수)

- **입력 객체(특히 mutable)의 내부 상태를 직접 변경**
- 예시: 리스트의 `append()`, `sort()` 등

```python
def destructive_append(lst, item):
lst.append(item) # 원본 리스트가 변경됨
```


#### 🟢 Undestructive function (비파괴적 함수)

- **입력 객체를 변경하지 않고, 새로운 객체 반환**
- 예시: `sorted()`, `+` 연산 등

```python
def undestructive_append(lst, item):
return lst + [item] # 새로운 리스트 반환, 원본은 그대로
```

| 구분 | Destructive function | Undestructive function |
| :-- | :-- | :-- |
| 원본 객체 변화 | 변경됨 | 변경되지 않음 |
| 반환 값 | 보통 None 또는 변경된 객체 | 보통 새로운 객체 |
| 예시 | `list.append()`, `sort()` | `sorted()`, `+` 연산 |
| 사용 목적 | 메모리 절약, 직접 수정 | 안전성, 불변성 유지 |

---

### 🌟 가변 인자: *args, **kwargs

- **함수 인자의 개수/형식을 유연하게 처리**  
- 대표적으로 `*args`, `**kwargs` 사용

#### *args

- 여러 **위치 인자**를 하나의 튜플로 받음

```python
def print_args(*args):
for arg in args:
print(arg)

print_args(1, 2, 3) # 1, 2, 3 출력
```

#### **kwargs

- 여러 **키워드 인자**를 하나의 딕셔너리로 받음

```python
def print_kwargs(**kwargs):
for key, value in kwargs.items():
print(key, value)

print_kwargs(name="Alice", age=30)

#name Alice
#age 30
```

#### *args와 **kwargs 함께 쓰기

- 항상 `*args`가 먼저, `**kwargs`가 나중에 와야 함


| 구분 | 역할 | 함수 내 자료형 |
| :-- | :-- | :-- |
| *args | 위치 인자를 튜플로 받음 | tuple |
| **kwargs | 키워드 인자를 딕셔너리로 받음 | dict |

---

### 🪄 Decorator

- **함수나 메서드 코드를 직접 수정하지 않고, 기능을 확장/변경**하는 문법
- `@데코레이터이름` 형태로 함수 선언부 위에 사용
- 다른 함수를 인자로 받아, 새로운 함수를 반환하는 **고차 함수**

#### 🏗️ 기본 사용법

```python
def my_decorator(func):
def wrapper():
print("함수 실행 전")
func()
print("함수 실행 후")
return wrapper

@my_decorator
def say_hello():
print("Hello!")

say_hello()

#함수 실행 전
#Hello!
#함수 실행 후
```

#### 💡 활용 예시

- 로깅(logging)
- 실행 시간 측정
- 입력값 검증
- 접근 권한 제어

#### 📝 참고

- 데코레이터 사용 시 `functools.wraps`로 원본 함수 메타정보 보존 권장
- 여러 데코레이터 중첩 적용 가능

---
