# 📅 4주차 - 17일차

## 🧱 데이터 무결성과 제약조건: 신뢰할 수 있는 데이터베이스 만들기

오늘은 데이터베이스의 신뢰도를 높이는 핵심 요소인 **데이터 무결성(Data Integrity)**과 이를 강제하는 **제약조건(Constraints)**에 대해 학습했다. 또한, 데이터베이스의 성능을 좌우하는 **인덱스(Index)**와 가상 테이블인 **뷰(View)**, 그리고 분석에 유용한 **윈도우 함수(Window Function)**까지 다루었다.

> ### 💡 왜 데이터 무결성이 중요할까?
> 데이터베이스는 단순히 데이터를 저장하는 창고가 아니다. 데이터가 정확하고 일관성을 유지해야만 의미 있는 정보를 제공할 수 있다. 제약조건은 잘못된 데이터가 입력되는 것을 막아주는 든든한 문지기 역할을 한다.

---

### ⛓️ 1. 제약조건(Constraints)의 종류

| 종류 | 설명 | 특징 |
| :--- | :--- | :--- |
| **`PRIMARY KEY` (기본 키)** | 테이블의 각 행을 **고유하게 식별**하는 값. | `NOT NULL`과 `UNIQUE` 속성을 모두 가짐. (예: 사원 번호) |
| **`FOREIGN KEY` (외래 키)** | 다른 테이블의 `PRIMARY KEY`를 참조. | 테이블 간의 **관계**를 정의. (예: 사원 테이블의 부서 번호) |
| **`UNIQUE`** | 해당 열의 모든 값이 **중복되지 않도록** 보장. | `NULL` 값을 허용. (예: 이메일 주소) |
| **`NOT NULL`** | 해당 열에 **반드시 값이 있어야** 함. | `NULL` 값을 허용하지 않음. |
| **`CHECK`** | 저장될 데이터가 **특정 조건**을 만족하는지 검사. | (예: 나이는 0보다 커야 함) |
| **`DEFAULT`** | 값을 입력하지 않았을 때 **자동으로 저장될 기본값**을 지정. | (예: 가입일자를 `NOW()`로 설정) |

#### 외래 키(Foreign Key)의 옵션: `ON DELETE`, `ON UPDATE`

- 참조하는 부모 테이블의 데이터가 변경(삭제/수정)될 때, 자식 테이블의 데이터를 어떻게 처리할지 결정한다.

| 옵션 | 설명 |
| :--- | :--- |
| **`CASCADE`** | 부모 데이터가 변경되면, 자식 데이터도 **함께 변경/삭제**된다. |
| **`SET NULL`** | 부모 데이터가 변경되면, 자식 데이터는 **`NULL`로 설정**된다. |
| **`NO ACTION` / `RESTRICT`** | 자식 데이터가 존재하면, 부모 데이터의 변경/삭제를 **허용하지 않는다.** (기본값) |

---

### ⚡ 2. 인덱스(Index): 검색 속도를 높이는 마법

- **인덱스**는 책의 '찾아보기'처럼 데이터베이스 테이블의 검색 속도를 향상시키는 자료구조다.
- `WHERE` 절에서 자주 사용되는 열에 인덱스를 설정하면, 테이블 전체를 스캔하지 않고 빠르게 원하는 데이터를 찾을 수 있다.
- **`PRIMARY KEY`** 와 **`UNIQUE`** 제약조건을 설정하면 해당 열에 자동으로 인덱스가 생성된다.

> **주의!** 인덱스는 `INSERT`, `UPDATE`, `DELETE` 작업 시 추가적인 처리 비용이 발생하므로, 무분별한 사용은 오히려 성능 저하를 유발할 수 있다.

---

### 🎭 3. 뷰(View): 가상의 테이블

- **뷰**는 하나 이상의 테이블을 기반으로 만들어진 **논리적인 가상 테이블**이다.
- 복잡한 쿼리를 단순화하고, 보안을 위해 특정 열만 노출시키는 등 다양한 용도로 활용된다.

```sql
-- emp 테이블과 dept 테이블을 조인하여 자주 사용하는 정보를 뷰로 만들기
CREATE VIEW v_emp_dept AS
SELECT e.empno, e.ename, d.dname, d.loc
FROM emp e
JOIN dept d ON e.deptno = d.deptno;

-- 이제 복잡한 조인 없이 뷰를 간단히 조회할 수 있다.
SELECT * FROM v_emp_dept WHERE dname = 'SALES';
```

- 뷰는 실제 데이터를 저장하지 않고, 뷰를 조회할 때마다 원본 테이블에 접근하여 결과를 보여준다.

---

### 윈도우 함수(Window Functions): 데이터 분석의 날개

- **윈도우 함수**는 행과 행 간의 관계를 쉽게 정의하고 계산할 수 있게 해주는 강력한 분석 도구다.
- `OVER()` 절과 함께 사용되며, 데이터를 특정 기준으로 분할(`PARTITION BY`)하고 정렬(`ORDER BY`)하여 순위, 합계, 평균 등을 계산한다.

| 함수 | 설명 |
| :--- | :--- |
| **`RANK()`** | 순위를 매기되, 공동 순위가 있으면 다음 등수는 건너뛴다. (1, 2, 2, 4) |
| **`DENSE_RANK()`** | 공동 순위가 있어도 다음 등수를 건너뛰지 않는다. (1, 2, 2, 3) |
| **`ROW_NUMBER()`** | 순위에 상관없이 고유한 번호를 부여한다. (1, 2, 3, 4) |
| **`SUM() OVER(...)`** | 파티션 별 누적 합계를 구한다. |
| **`LAG()`, `LEAD()`** | 현재 행을 기준으로 이전/이후 행의 값을 가져온다. |

```sql
-- 부서별로 급여가 높은 순서대로 순위를 매긴다.
SELECT
    ename,
    sal,
    dname,
    RANK() OVER (PARTITION BY dname ORDER BY sal DESC) AS sal_rank
FROM v_emp_dept;
```

---

### ✨ 오늘 배운 것 요약

- **제약조건**은 데이터의 **무결성**을 지키는 필수적인 장치임을 이해했다.
- **인덱스**는 **검색 성능**을 향상시키지만, 데이터 변경 시 부하가 발생할 수 있음을 배웠다.
- **뷰**는 복잡한 쿼리를 **단순화**하고 **보안**을 강화하는 데 유용한 가상 테이블임을 알게 되었다.
- **윈도우 함수**를 사용하면 복잡한 하위 쿼리 없이도 **데이터 분석**을 효율적으로 수행할 수 있음을 확인했다.
