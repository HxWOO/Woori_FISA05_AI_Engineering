# 📅 4주차 - 16일차

## 🤝 SQL JOIN과 Subquery: 데이터베이스의 꽃

오늘은 관계형 데이터베이스의 가장 강력하고 핵심적인 기능인 **JOIN**과 **Subquery**에 대해 깊이 파고들었다. 흩어져 있는 데이터 조각들을 자유자재로 합치고, 쿼리 속에 또 다른 쿼리를 넣어 복잡한 문제를 해결하는 방법을 익혔다.

> ### 💡 JOIN과 Subquery, 왜 마스터해야 할까?
> 잘 설계된 데이터베이스는 여러 테이블에 정보가 나뉘어 저장된다. **JOIN**은 이 테이블들을 다시 합쳐 의미 있는 정보를 만드는 열쇠이며, **Subquery**는 동적인 상황에 맞춰 똑똑하게 데이터를 조회하는 비밀 무기와 같다. 이 둘을 잘 다루어야 진정한 데이터 전문가로 거듭날 수 있다.

---

### 🛠️ JOIN의 종류: 테이블을 합치는 다양한 방법

| 종류 | 설명 | 특징 |
| :--- | :--- | :--- |
| **INNER JOIN (내부 조인)** | 두 테이블에 **모두 존재하는** 데이터만 연결 | 가장 흔하고 기본적인 조인. |
| **OUTER JOIN (외부 조인)** | 한쪽 테이블에만 데이터가 있어도 결과에 포함 | `LEFT`, `RIGHT`가 있으며, 데이터 누락을 방지할 때 사용. |
| **CROSS JOIN (교차 조인)** | 한쪽 테이블의 모든 행을 다른 쪽 테이블의 모든 행과 연결 | 모든 경우의 수를 확인할 때 사용. (결과가 매우 커질 수 있음) |
| **SELF JOIN (자체 조인)** | 하나의 테이블을 **두 개인 것처럼** 간주하고 스스로를 조인 | 사원과 관리자처럼 계층적인 관계를 분석할 때 유용. |

#### 1. INNER JOIN: 교집합 찾기

- 두 테이블의 조인 조건이 **정확히 일치하는 행**만 결과로 보여준다.

```sql
-- 사원(emp)과 부서(dept) 테이블에서 부서 번호가 같은 데이터를 찾아 연결
SELECT
    e.ename,  -- 사원 이름
    d.dname   -- 부서 이름
FROM
    emp e
INNER JOIN dept d ON e.deptno = d.deptno; -- INNER JOIN은 그냥 JOIN으로 써도 동일하게 작동한다.
```

#### 2. OUTER JOIN: 한쪽은 모두 보여주기

- 조인 조건이 맞지 않더라도, 특정 테이블의 데이터는 **하나도 빠짐없이** 보고 싶을 때 사용한다.

| 구분 | 설명 |
| :--- | :--- |
| **LEFT JOIN** | **왼쪽 테이블**의 모든 데이터를 보여주고, 오른쪽 테이블은 일치하는 데이터만. (없으면 `NULL`) |
| **RIGHT JOIN** | **오른쪽 테이블**의 모든 데이터를 보여주고, 왼쪽 테이블은 일치하는 데이터만. (없으면 `NULL`) |

```sql
-- 모든 부서의 목록을 보여주되, 해당 부서에 속한 사원이 있으면 함께 출력
SELECT
    d.dname,
    e.ename
FROM
    dept d
LEFT JOIN emp e ON d.deptno = e.deptno; -- 부서(dept)는 모두, 사원(emp)은 있는 경우만 보여준다.
```

#### 3. SELF JOIN: 나 자신과 조인하기

- **하나의 테이블**에 모든 정보가 있지만, 그 안에서 관계를 찾아야 할 때 사용한다.
- 별칭(Alias)을 이용해 마치 두 개의 다른 테이블인 것처럼 다루는 것이 핵심이다.

```sql
-- 각 사원의 이름과 그 사원의 관리자 이름을 함께 출력
SELECT
    e1.ename AS "사원", -- 별칭 e1: 부하직원 테이블로 간주
    e2.ename AS "관리자" -- 별칭 e2: 상사 테이블로 간주
FROM
    emp e1
LEFT JOIN emp e2 ON e1.mgr = e2.empno; -- 사원의 관리자 번호(mgr)와 상사의 사원 번호(empno)를 연결
```

---

## 🔍 Subquery: 쿼리 속의 쿼리

**서브쿼리(Subquery)** 는 하나의 SQL 쿼리 문장 안에 포함된 또 다른 `SELECT` 쿼리다. 복잡한 문제를 여러 단계로 나누어 명쾌하게 해결할 수 있게 해준다.

> ### 💡 서브쿼리는 언제 사용할까?
> - **동적인 조건**을 만들고 싶을 때 (예: 'SMITH'와 같은 부서에 있는 모든 사원 찾기)
> - **아직 모르는 값**을 조건으로 사용해야 할 때 (예: 가장 높은 급여를 받는 사원 정보 찾기)

---

### 🎯 서브쿼리의 위치와 종류

서브쿼리는 `SELECT`, `FROM`, `WHERE` 등 다양한 곳에 등장하며, 위치에 따라 다른 이름으로 불린다.

| 위치 | 이름 | 설명 |
| :--- | :--- | :--- |
| **`SELECT` 절** | **스칼라 서브쿼리** | 단 하나의 값(하나의 행, 하나의 열)만 반환해야 함. |
| **`FROM` 절** | **인라인 뷰** | 쿼리 결과를 하나의 가상 테이블처럼 사용. (반드시 별칭 필요) |
| **`WHERE` 절** | **중첩 서브쿼리** | 조건문에서 사용. `IN`, `ANY`, `ALL`, `EXISTS` 등과 함께 쓰임. |

#### 1. WHERE 절에서 사용하기

- 가장 일반적인 형태로, 다른 쿼리의 결과를 조건으로 받아 필터링한다.

```sql
-- 'SMITH'와 같은 부서에서 근무하는 모든 사원을 검색 (SMITH는 제외)
SELECT ename, deptno
FROM emp
WHERE deptno = (SELECT deptno FROM emp WHERE ename = 'SMITH') -- 'SMITH'의 부서 번호를 찾아서 조건으로 사용
  AND ename != 'SMITH';
```

#### 2. FROM 절에서 사용하기 (인라인 뷰)

- 서브쿼리의 결과를 **임시 테이블**처럼 간주하고, 다른 테이블과 조인하거나 추가 연산을 할 수 있다.

```sql
-- 각 부서별 평균 급여를 구하고, 해당 부서의 정보와 함께 출력
SELECT
    d.dname,
    e_avg.avg_sal
FROM
    dept d
JOIN (SELECT deptno, AVG(sal) AS avg_sal FROM emp GROUP BY deptno) AS e_avg
  ON d.deptno = e_avg.deptno;
```

#### 3. CTE (Common Table Expression) - `WITH` 절

- 복잡한 서브쿼리를 **재사용**하거나 쿼리를 더 **읽기 쉽게** 만들고 싶을 때 사용하는 세련된 방법이다.
- `WITH` 키워드로 서브쿼리에 이름을 붙여주고, 메인 쿼리에서 해당 이름을 테이블처럼 편하게 가져다 쓸 수 있다.

```sql
-- 직군이 'MANAGER'인 사람들의 부서명, 이름, 직군을 출력
WITH manager_info AS (
    SELECT ename, job, deptno
    FROM emp
    WHERE job = 'MANAGER'
)
SELECT
    d.dname,
    m.ename,
    m.job
FROM
    dept d
JOIN manager_info m ON d.deptno = m.deptno;
```

> ### ✨ CTE vs 서브쿼리
> - **가독성**: CTE는 복잡한 쿼리를 논리적으로 분리하여 훨씬 읽기 좋다.
> - **재사용성**: 하나의 CTE를 여러 번 참조할 수 있어 반복을 줄인다.
> - **성능**: 경우에 따라 CTE가 더 나은 최적화를 제공하기도 한다.

---

### ✨ 오늘 배운 것 요약

- **JOIN**은 분리된 테이블을 **연결**하여 풍부한 정보를 만드는 핵심 기능임을 이해했다.
- **Subquery**는 쿼리 안에 또 다른 쿼리를 넣어 **복잡한 조건**을 해결하는 유용한 도구임을 배웠다.
- **CTE (`WITH` 절)** 는 서브쿼리를 더 **체계적이고 읽기 쉽게** 만들어주는 세련된 방법임을 알게 되었다.
- 이 세 가지를 자유자재로 활용하면 대부분의 데이터 조회 문제를 멋지게 해결할 수 있다
